<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Blast Clone</title>
    <style>
        :root {
            --bg-color: #121213;
            --grid-bg: #1e1e20;
            --cell-border: #3a3a3c;
            --text-color: white;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        .header {
            margin-top: 20px;
            text-align: center;
        }

        #score {
            font-size: 2rem;
            font-weight: bold;
        }

        /* Ana Izgara */
        #grid {
            display: grid;
            grid-template-columns: repeat(8, 45px);
            grid-template-rows: repeat(8, 45px);
            gap: 4px;
            background-color: var(--grid-bg);
            padding: 8px;
            border-radius: 8px;
            margin-top: 20px;
            user-select: none;
        }

        .cell {
            width: 45px;
            height: 45px;
            background-color: #2c2c2e;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        /* Alttaki Blok Seçenekleri */
        #piece-container {
            display: flex;
            gap: 20px;
            margin-top: 40px;
            height: 120px;
            align-items: center;
        }

        .piece {
            display: grid;
            gap: 2px;
            cursor: grab;
            transition: transform 0.1s;
        }

        .piece-cell {
            width: 25px;
            height: 25px;
            border-radius: 3px;
        }

        .dragging {
            opacity: 0.8;
            transform: scale(1.1);
            cursor: grabbing;
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        /* Renkler */
        .color-1 { background-color: #ff3b30; } /* Kırmızı */
        .color-2 { background-color: #ff9500; } /* Turuncu */
        .color-3 { background-color: #ffcc00; } /* Sarı */
        .color-4 { background-color: #4cd964; } /* Yeşil */
        .color-5 { background-color: #5ac8fa; } /* Açık Mavi */
        .color-6 { background-color: #007aff; } /* Mavi */
        .color-7 { background-color: #5856d6; } /* Mor */

        .filled { border: none; }
    </style>
</head>
<body>

    <div class="header">
        <div>SKOR</div>
        <div id="score">0</div>
    </div>

    <div id="grid"></div>

    <div id="piece-container"></div>

    <script>
        const GRID_SIZE = 8;
        const gridElement = document.getElementById('grid');
        const pieceContainer = document.getElementById('piece-container');
        const scoreElement = document.getElementById('score');
        
        let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        let score = 0;
        let activeDraggingPiece = null;

        // Blok Şekilleri
        const PIECE_TYPES = [
            { shape: [[1, 1], [1, 1]], color: 1 }, // Kare
            { shape: [[1, 1, 1, 1]], color: 2 },    // Yatay Çubuk
            { shape: [[1], [1], [1], [1]], color: 2 }, // Dikey Çubuk
            { shape: [[1, 1, 1]], color: 3 },       // Kısa Yatay
            { shape: [[1, 0], [1, 0], [1, 1]], color: 4 }, // L Şekli
            { shape: [[0, 1], [0, 1], [1, 1]], color: 5 }, // Ters L
            { shape: [[1, 1, 1], [0, 1, 0]], color: 6 },   // T Şekli
            { shape: [[1]], color: 7 }              // Tekli Blok
        ];

        // Izgarayı Oluştur
        function createGrid() {
            gridElement.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gridElement.appendChild(cell);
                }
            }
        }

        // Yeni Parçalar Üret
        function spawnPieces() {
            pieceContainer.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const randomType = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
                const pieceDiv = document.createElement('div');
                pieceDiv.classList.add('piece');
                pieceDiv.style.gridTemplateColumns = `repeat(${randomType.shape[0].length}, 25px)`;
                
                randomType.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        const cell = document.createElement('div');
                        cell.classList.add('piece-cell');
                        if (value) cell.classList.add(`color-${randomType.color}`);
                        else cell.style.opacity = '0';
                        pieceDiv.appendChild(cell);
                    });
                });

                pieceDiv.addEventListener('mousedown', (e) => startDrag(e, randomType, pieceDiv));
                pieceContainer.appendChild(pieceDiv);
            }
        }

        // Sürükleme Başlat
        function startDrag(e, pieceData, element) {
            const clone = element.cloneNode(true);
            clone.classList.add('dragging');
            document.body.appendChild(clone);
            
            const moveAt = (pageX, pageY) => {
                clone.style.left = pageX - clone.offsetWidth / 2 + 'px';
                clone.style.top = pageY - clone.offsetHeight / 2 + 'px';
            };

            moveAt(e.pageX, e.pageY);

            const onMouseMove = (ev) => {
                moveAt(ev.pageX, ev.pageY);
            };

            document.addEventListener('mousemove', onMouseMove);

            clone.onmouseup = (ev) => {
                document.removeEventListener('mousemove', onMouseMove);
                const rect = gridElement.getBoundingClientRect();
                
                // Fare koordinatlarından grid hücresini bul
                const col = Math.floor((ev.clientX - rect.left) / 49);
                const row = Math.floor((ev.clientY - rect.top) / 49);

                if (canPlace(pieceData.shape, row, col)) {
                    placePiece(pieceData, row, col);
                    element.remove();
                    checkLines();
                    if (pieceContainer.children.length === 0) spawnPieces();
                    checkGameOver();
                }

                clone.remove();
            };
        }

        // Yerleştirilebilir mi kontrolü
        function canPlace(shape, row, col) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        let targetR = row + r;
                        let targetC = col + c;
                        if (targetR < 0 || targetR >= GRID_SIZE || targetC < 0 || targetC >= GRID_SIZE || grid[targetR][targetC] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // Parçayı Yerleştir
        function placePiece(pieceData, row, col) {
            pieceData.shape.forEach((rArr, r) => {
                rArr.forEach((val, c) => {
                    if (val) {
                        grid[row + r][col + c] = pieceData.color;
                        const cell = gridElement.children[(row + r) * GRID_SIZE + (col + c)];
                        cell.classList.add(`color-${pieceData.color}`, 'filled');
                        score += 10;
                    }
                });
            });
            updateScore();
        }

        // Dolu satır/sütun kontrolü
        function checkLines() {
            let rowsToRemove = [];
            let colsToRemove = [];

            for (let i = 0; i < GRID_SIZE; i++) {
                if (grid[i].every(val => val !== 0)) rowsToRemove.push(i);
                if (grid.map(row => row[i]).every(val => val !== 0)) colsToRemove.push(i);
            }

            rowsToRemove.forEach(r => {
                for (let c = 0; c < GRID_SIZE; c++) grid[r][c] = 0;
                score += 100;
            });

            colsToRemove.forEach(c => {
                for (let r = 0; r < GRID_SIZE; r++) grid[r][c] = 0;
                score += 100;
            });

            updateVisuals();
        }

        function updateVisuals() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = gridElement.children[r * GRID_SIZE + c];
                    cell.className = 'cell' + (grid[r][c] ? ` color-${grid[r][c]} filled` : '');
                }
            }
            updateScore();
        }

        function updateScore() {
            scoreElement.innerText = score;
        }

        function checkGameOver() {
            // Basitçe: Kalan her parça için grid üzerinde yer var mı bak
            // Bu örnekte basitleştirilmiştir.
        }

        // Başlat
        createGrid();
        spawnPieces();

    </script>
</body>
</html>
