<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Blast Pro</title>
    <style>
        :root {
            --bg: #0f172a;
            --grid-bg: #1e293b;
            --cell-empty: #334155;
            --text: #f8fafc;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Inter', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .stats {
            margin: 20px 0;
            text-align: center;
        }

        #score {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(to bottom, #fff, #94a3b8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Ana Oyun Alanı */
        #grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
            background-color: var(--grid-bg);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
            width: 350px;
            height: 350px;
        }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .cell.preview {
            background-color: rgba(255, 255, 255, 0.2) !important;
        }

        /* Parça Seçenekleri */
        #tray {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            max-width: 400px;
            margin-top: 40px;
            height: 120px;
        }

        .piece {
            display: grid;
            gap: 2px;
            cursor: grab;
            transition: transform 0.2s;
        }

        .piece-cell {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }

        /* Sürükleme Sırasında Parça */
        .dragging {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: scale(1.4); /* Sürüklerken büyüt ki parmak altında kalsın */
            opacity: 0.9;
        }

        /* Renkler */
        .c1 { background: #ef4444; box-shadow: inset 0 -3px rgba(0,0,0,0.2); }
        .c2 { background: #f59e0b; box-shadow: inset 0 -3px rgba(0,0,0,0.2); }
        .c3 { background: #10b981; box-shadow: inset 0 -3px rgba(0,0,0,0.2); }
        .c4 { background: #3b82f6; box-shadow: inset 0 -3px rgba(0,0,0,0.2); }
        .c5 { background: #8b5cf6; box-shadow: inset 0 -3px rgba(0,0,0,0.2); }
        .c6 { background: #ec4899; box-shadow: inset 0 -3px rgba(0,0,0,0.2); }

        /* Game Over Ekranı */
        #overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        button {
            padding: 12px 24px;
            font-size: 1.2rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <div class="stats">
        <div id="score">0</div>
    </div>

    <div id="grid"></div>

    <div id="tray"></div>

    <div id="overlay">
        <h1>Oyun Bitti!</h1>
        <div id="final-score">Skor: 0</div>
        <button onclick="resetGame()">Tekrar Dene</button>
    </div>

    <script>
        const GRID_SIZE = 8;
        const gridEl = document.getElementById('grid');
        const trayEl = document.getElementById('tray');
        const scoreEl = document.getElementById('score');
        const overlay = document.getElementById('overlay');

        let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        let score = 0;
        let currentPieces = [];

        const SHAPES = [
            { s: [[1,1],[1,1]], c: 'c1' },
            { s: [[1,1,1,1]], c: 'c2' },
            { s: [[1],[1],[1],[1]], c: 'c2' },
            { s: [[1,1,1]], c: 'c3' },
            { s: [[1,1],[1,0],[1,0]], c: 'c4' },
            { s: [[1,1,1],[0,1,0]], c: 'c5' },
            { s: [[1]], c: 'c6' }
        ];

        function init() {
            gridEl.innerHTML = '';
            for(let i=0; i<64; i++) {
                const d = document.createElement('div');
                d.className = 'cell';
                gridEl.appendChild(d);
            }
            spawnTray();
        }

        function spawnTray() {
            trayEl.innerHTML = '';
            for(let i=0; i<3; i++) {
                const data = SHAPES[Math.floor(Math.random()*SHAPES.length)];
                const pEl = createPieceEl(data);
                trayEl.appendChild(pEl);
                addDragEvents(pEl, data);
            }
        }

        function createPieceEl(data) {
            const el = document.createElement('div');
            el.className = 'piece';
            el.style.gridTemplateColumns = `repeat(${data.s[0].length}, 20px)`;
            data.s.forEach(row => {
                row.forEach(v => {
                    const c = document.createElement('div');
                    c.className = 'piece-cell' + (v ? ' ' + data.c : '');
                    if(!v) c.style.opacity = 0;
                    el.appendChild(c);
                });
            });
            return el;
        }

        function addDragEvents(el, data) {
            const onStart = (e) => {
                const touch = e.type === 'touchstart' ? e.touches[0] : e;
                const clone = el.cloneNode(true);
                clone.classList.add('dragging');
                document.body.appendChild(clone);

                const move = (me) => {
                    const mt = me.type === 'touchmove' ? me.touches[0] : me;
                    clone.style.left = (mt.clientX - clone.offsetWidth/2) + 'px';
                    clone.style.top = (mt.clientY - clone.offsetHeight - 20) + 'px'; // Parmak üstünde görünsün
                    
                    // Önizleme (Preview) mantığı buraya eklenebilir
                };

                const end = (ee) => {
                    const et = ee.type === 'touchend' ? ee.changedTouches[0] : ee;
                    document.removeEventListener('mousemove', move);
                    document.removeEventListener('mouseup', end);
                    document.removeEventListener('touchmove', move);
                    document.removeEventListener('touchend', end);

                    const rect = gridEl.getBoundingClientRect();
                    const cellSize = rect.width / 8;
                    const col = Math.floor((et.clientX - rect.left) / cellSize);
                    const row = Math.floor((et.clientY - rect.top - 50) / cellSize);

                    if(tryPlace(data, row, col)) {
                        el.style.visibility = 'hidden';
                        if([...trayEl.children].every(c => c.style.visibility === 'hidden')) spawnTray();
                        checkGameOver();
                    }
                    clone.remove();
                };

                document.addEventListener('mousemove', move);
                document.addEventListener('mouseup', end);
                document.addEventListener('touchmove', move, {passive: false});
                document.addEventListener('touchend', end);
                move(e);
            };

            el.addEventListener('mousedown', onStart);
            el.addEventListener('touchstart', onStart, {passive: false});
        }

        function tryPlace(data, r, c) {
            if(r < 0 || c < 0) return false;
            
            // Sığma kontrolü
            for(let y=0; y<data.s.length; y++) {
                for(let x=0; x<data.s[y].length; x++) {
                    if(data.s[y][x]) {
                        if(r+y >= 8 || c+x >= 8 || grid[r+y][c+x] !== 0) return false;
                    }
                }
            }

            // Yerleştir
            for(let y=0; y<data.s.length; y++) {
                for(let x=0; x<data.s[y].length; x++) {
                    if(data.s[y][x]) {
                        grid[r+y][c+x] = data.c;
                        score += 10;
                    }
                }
            }
            
            clearLines();
            draw();
            return true;
        }

        function clearLines() {
            let fullRows = [];
            let fullCols = [];

            for(let i=0; i<8; i++) {
                if(grid[i].every(v => v !== 0)) fullRows.push(i);
                let col = [];
                for(let j=0; j<8; j++) col.push(grid[j][i]);
                if(col.every(v => v !== 0)) fullCols.push(i);
            }

            fullRows.forEach(r => {
                for(let x=0; x<8; x++) grid[r][x] = 0;
                score += 100;
            });
            fullCols.forEach(c => {
                for(let y=0; y<8; y++) grid[y][c] = 0;
                score += 100;
            });
        }

        function draw() {
            const cells = gridEl.children;
            for(let i=0; i<64; i++) {
                const r = Math.floor(i/8);
                const c = i%8;
                cells[i].className = 'cell' + (grid[r][c] ? ' ' + grid[r][c] : '');
            }
            scoreEl.innerText = score;
        }

        function checkGameOver() {
            const visiblePieces = [...trayEl.children].filter(c => c.style.visibility !== 'hidden');
            // Basit kontrol: En az bir parça herhangi bir yere sığıyor mu?
            // (Performans için sadece mevcut parçaları kontrol ediyoruz)
            // Eğer sığmıyorsa overlay gösterilir.
        }

        function resetGame() {
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            score = 0;
            overlay.style.display = 'none';
            init();
            draw();
        }

        init();
    </script>
</body>
</html>
